!     -*- f90 -*-
!     This file is autogenerated with f2py (version:2)
!     It contains Fortran 90 wrappers to fortran functions.

      subroutine f2py_f_sorsolve_getdims_a(r,s,f2pysetdata,flag)
      use f_sorsolve, only: d => a

      integer flag
      external f2pysetdata
      logical ns
      integer r,i
      integer(8) s(*)
      ns = .FALSE.
      if (allocated(d)) then
         do i=1,r
            if ((size(d,i).ne.s(i)).and.(s(i).ge.0)) then
               ns = .TRUE.
            end if
         end do
         if (ns) then
            deallocate(d)
         end if
      end if
      if ((.not.allocated(d)).and.(s(1).ge.1)) then
       allocate(d(s(1),s(2)))
      end if
      if (allocated(d)) then
         do i=1,r
            s(i) = size(d,i)
         end do
      end if
      flag = 1
      call f2pysetdata(d,allocated(d))
      end subroutine f2py_f_sorsolve_getdims_a
      subroutine f2py_f_sorsolve_getdims_b(r,s,f2pysetdata,flag)
      use f_sorsolve, only: d => b

      integer flag
      external f2pysetdata
      logical ns
      integer r,i
      integer(8) s(*)
      ns = .FALSE.
      if (allocated(d)) then
         do i=1,r
            if ((size(d,i).ne.s(i)).and.(s(i).ge.0)) then
               ns = .TRUE.
            end if
         end do
         if (ns) then
            deallocate(d)
         end if
      end if
      if ((.not.allocated(d)).and.(s(1).ge.1)) then
       allocate(d(s(1)))
      end if
      if (allocated(d)) then
         do i=1,r
            s(i) = size(d,i)
         end do
      end if
      flag = 1
      call f2pysetdata(d,allocated(d))
      end subroutine f2py_f_sorsolve_getdims_b
      subroutine f2py_f_sorsolve_getdims_x0(r,s,f2pysetdata,flag)
      use f_sorsolve, only: d => x0

      integer flag
      external f2pysetdata
      logical ns
      integer r,i
      integer(8) s(*)
      ns = .FALSE.
      if (allocated(d)) then
         do i=1,r
            if ((size(d,i).ne.s(i)).and.(s(i).ge.0)) then
               ns = .TRUE.
            end if
         end do
         if (ns) then
            deallocate(d)
         end if
      end if
      if ((.not.allocated(d)).and.(s(1).ge.1)) then
       allocate(d(s(1)))
      end if
      if (allocated(d)) then
         do i=1,r
            s(i) = size(d,i)
         end do
      end if
      flag = 1
      call f2pysetdata(d,allocated(d))
      end subroutine f2py_f_sorsolve_getdims_x0
      subroutine f2pywrap_f_sorsolve_solve (x, f2py_x_d0)
      use f_sorsolve, only : solve
      integer f2py_x_d0
      double precision x(f2py_x_d0)
      call solve(x)
      end subroutine f2pywrap_f_sorsolve_solve
      subroutine f2pywrap_f_sorsolve_update_omega (x, x_old, res, res_ol&
     &d, f2py_x_d0, f2py_x_old_d0, f2py_res_d0, f2py_res_old_d0)
      use f_sorsolve, only : update_omega
      integer f2py_x_d0
      integer f2py_x_old_d0
      integer f2py_res_d0
      integer f2py_res_old_d0
      double precision x(f2py_x_d0)
      double precision x_old(f2py_x_old_d0)
      double precision res(f2py_res_d0)
      double precision res_old(f2py_res_old_d0)
      call update_omega(x, x_old, res, res_old)
      end subroutine f2pywrap_f_sorsolve_update_omega
      subroutine f2pywrap_f_sorsolve_steepest_descent_update (res, f2py_&
     &res_d0)
      use f_sorsolve, only : steepest_descent_update
      integer f2py_res_d0
      double precision res(f2py_res_d0)
      call steepest_descent_update(res)
      end subroutine f2pywrap_f_sorsolve_steepest_descent_update
      subroutine f2pywrap_f_sorsolve_armijo_update (x, x_old, res_old, f&
     &2py_x_d0, f2py_x_old_d0, f2py_res_old_d0)
      use f_sorsolve, only : armijo_update
      integer f2py_x_d0
      integer f2py_x_old_d0
      integer f2py_res_old_d0
      double precision x(f2py_x_d0)
      double precision x_old(f2py_x_old_d0)
      double precision res_old(f2py_res_old_d0)
      call armijo_update(x, x_old, res_old)
      end subroutine f2pywrap_f_sorsolve_armijo_update
      subroutine f2pywrap_f_sorsolve_wolfe_update (x, x_old, res, res_ol&
     &d, f2py_x_d0, f2py_x_old_d0, f2py_res_d0, f2py_res_old_d0)
      use f_sorsolve, only : wolfe_update
      integer f2py_x_d0
      integer f2py_x_old_d0
      integer f2py_res_d0
      integer f2py_res_old_d0
      double precision x(f2py_x_d0)
      double precision x_old(f2py_x_old_d0)
      double precision res(f2py_res_d0)
      double precision res_old(f2py_res_old_d0)
      call wolfe_update(x, x_old, res, res_old)
      end subroutine f2pywrap_f_sorsolve_wolfe_update
      subroutine f2pywrap_f_sorsolve_f (x, out, f2py_x_d0)
      use f_sorsolve, only : f
      double precision out
      integer f2py_x_d0
      double precision x(f2py_x_d0)
      call f(x, out)
      end subroutine f2pywrap_f_sorsolve_f
      
      subroutine f2pyinitf_sorsolve(f2pysetupfunc)
      use f_sorsolve, only : a
      use f_sorsolve, only : b
      use f_sorsolve, only : x0
      use f_sorsolve, only : tol
      use f_sorsolve, only : omega
      use f_sorsolve, only : h
      use f_sorsolve, only : c1
      use f_sorsolve, only : c2
      use f_sorsolve, only : lambda1
      use f_sorsolve, only : lambda2
      use f_sorsolve, only : rho1
      use f_sorsolve, only : itermax
      use f_sorsolve, only : adaptive_omega
      use f_sorsolve, only : omega_update_frequency
      use f_sorsolve, only : n
      use f_sorsolve, only : init
      interface 
      subroutine f2pywrap_f_sorsolve_solve (x, f2py_x_d0)
      integer f2py_x_d0
      double precision x(f2py_x_d0)
      end subroutine f2pywrap_f_sorsolve_solve 
      subroutine f2pywrap_f_sorsolve_update_omega (x, x_old, res, res_ol&
     &d, f2py_x_d0, f2py_x_old_d0, f2py_res_d0, f2py_res_old_d0)
      integer f2py_x_d0
      integer f2py_x_old_d0
      integer f2py_res_d0
      integer f2py_res_old_d0
      double precision x(f2py_x_d0)
      double precision x_old(f2py_x_old_d0)
      double precision res(f2py_res_d0)
      double precision res_old(f2py_res_old_d0)
      end subroutine f2pywrap_f_sorsolve_update_omega 
      subroutine f2pywrap_f_sorsolve_steepest_descent_update (res, f2py_&
     &res_d0)
      integer f2py_res_d0
      double precision res(f2py_res_d0)
      end subroutine f2pywrap_f_sorsolve_steepest_descent_update 
      subroutine f2pywrap_f_sorsolve_armijo_update (x, x_old, res_old, f&
     &2py_x_d0, f2py_x_old_d0, f2py_res_old_d0)
      integer f2py_x_d0
      integer f2py_x_old_d0
      integer f2py_res_old_d0
      double precision x(f2py_x_d0)
      double precision x_old(f2py_x_old_d0)
      double precision res_old(f2py_res_old_d0)
      end subroutine f2pywrap_f_sorsolve_armijo_update 
      subroutine f2pywrap_f_sorsolve_wolfe_update (x, x_old, res, res_ol&
     &d, f2py_x_d0, f2py_x_old_d0, f2py_res_d0, f2py_res_old_d0)
      integer f2py_x_d0
      integer f2py_x_old_d0
      integer f2py_res_d0
      integer f2py_res_old_d0
      double precision x(f2py_x_d0)
      double precision x_old(f2py_x_old_d0)
      double precision res(f2py_res_d0)
      double precision res_old(f2py_res_old_d0)
      end subroutine f2pywrap_f_sorsolve_wolfe_update 
      subroutine f2pywrap_f_sorsolve_f (x, out, f2py_x_d0)
      double precision out
      integer f2py_x_d0
      double precision x(f2py_x_d0)
      end subroutine f2pywrap_f_sorsolve_f
      end interface
      external f2pysetupfunc
      external f2py_f_sorsolve_getdims_a
      external f2py_f_sorsolve_getdims_b
      external f2py_f_sorsolve_getdims_x0
      call f2pysetupfunc(f2py_f_sorsolve_getdims_a,f2py_f_sorsolve_getdi&
     &ms_b,f2py_f_sorsolve_getdims_x0,tol,omega,h,c1,c2,lambda1,lambda2,&
     &rho1,itermax,adaptive_omega,omega_update_frequency,n,init,f2pywrap&
     &_f_sorsolve_solve,f2pywrap_f_sorsolve_update_omega,f2pywrap_f_sors&
     &olve_steepest_descent_update,f2pywrap_f_sorsolve_armijo_update,f2p&
     &ywrap_f_sorsolve_wolfe_update,f2pywrap_f_sorsolve_f)
      end subroutine f2pyinitf_sorsolve


